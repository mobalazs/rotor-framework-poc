
namespace ViewModels

    ' The following - less tehn 180 lines - will implement a complex behavior of initializing flow with using the best ptacties and more.

    class AppViewModel extends ViewModels.LayoutViewModel

        pagesViewModels = {
            home: ViewModels.HomePage,
            movies: ViewModels.MoviesPage,
            series: ViewModels.SeriesPage,
            playground1: ViewModels.Playground1Page,
            playground2: ViewModels.Playground2Page,
            settings: ViewModels.SettingsPage
        }

        override sub onCreateView()

            ' Get dispatcher facades
            m.appStoreDispatcher = m.getDispatcher("appStore")

            mapStateToProps = sub(props, state)
                props.activePageKey = state.activePageKey
            end sub

            ' get initial appstore state and append to this ViewModel's props
            m.appStoreDispatcher.getState(mapStateToProps)

            ' Setup dispatcher listeners
            m.appStoreDispatcher.addListener({
                shouldUpdate: function(props, newState) as object
                    return props.activePageKey <> newState.activePageKey
                end function,
                mapStateToProps: mapStateToProps,
                callback: "proceedPageTransition" ' refering to a method in this scope
            })

        end sub

        sub proceedPageTransition()
            activePageKey = m.props.activePageKey ' Using props which visible in the enttyre view (in every widget on layout)

            viewcontainer = m.getWidget("viewContainer")

            ' hide other pages
            for each childId in viewcontainer.children
                childNode = viewcontainer.children[childId].node
                childNode.visible = `page-${activePageKey}` = childId ' visible if equal
            end for

            ' If page is exist then make it visible, if does not exist then we need to create it.
            doesExistPage = viewcontainer.children.LookupCI(`page-${activePageKey}`) <> invalid

            m.renderPageTransition(activePageKey, doesExistPage)

        end sub

        override sub onDestroyView() ' call by View Builder
            m.appStoreDispatcher.destroy()
            m.appStoreDispatcher = invalid
            m.preloaderDispatcher.destroy()
            m.preloaderDispatcher = invalid
        end sub


        ' * PRELOADING / PRE-RENDERING implementation

        override sub afterViewMounted()
            m.startPreloading()
        end sub



        sub startPreloading() ' here we dont neeed props, we need these args just here

            m.showLoadingScreen()

            ' Get dispatcher facade
            m.preloaderDispatcher = m.getDispatcher("preloader")

            ' Listening for preloader
            m.preloaderDispatcher.addListener({
                shouldUpdate: function(props, newState) as object
                    return newState.resourcesReady = true
                end function,
                callback: m.onResourcesReady, ' refering to a method in this scope
                once: true
            })

            ' Actually start preloading
            m.preloaderDispatcher.dispatch({
                type: IntentType.PRELOADER.START_PRELOAD_RESOURCES
            })

        end sub

        sub onResourcesReady()
            ' PRE-RENDERING some pages (Async processes completed, now we can pre-render some nodes)
            preRendering = sub(widget, payload)
                if payload?.renderTracking = "full"

                    ' It is time to render our layout.

                    ' We are in the scope of the widget what we observered, but we are not lost..., we have a widget :)
                    ' Get the control over layout
                    layout = widget.getWidget("./layout")
                    currentAppStoreState = widget.context.dispatcher.appStore.getState()

                    layoutTemplate = layout.customLayoutTemplate()
                    layout.render(layoutTemplate)

                    ' Get the current state immediately (synchronously)

                    ' If you would like to pre-render some of your pages, here is how to do it:
                    for each pageKey in currentAppStoreState.pageList
                        pageSettings = currentAppStoreState.pageSettings[pageKey]
                        isEnabledPrerender = pageSettings.enablePrerender
                        if isEnabledPrerender = true
                            layout.prerenderPage(pageKey)
                        end if
                    end for

                    layout.preRenderingFinished()
                end if

            end sub

            ' During pre-rendering we should not run animation at all
            loadingScreen = m.getWidget("./loadingScreen")
            loadingScreen.erase("defaultSpinner")
            lastMomentLabel = loadingScreen.getWidget("lastMomentLabel")
            lastMomentLabel.render({
                fields: {
                    visible: true,
                    enableRenderTracking: true
                },
                observer: {
                    ' We are going to flood builder with pre-rendering requests, but:
                    ' Roku need time to render changes on screen ("One second left..." text)
                    ' What we're doing here is completely native and a generic approach in Rotor Builder.
                    fieldId: "renderTracking",
                    callback: preRendering
                },
                ' We will need tha appstore, and getting this via plugin is a very confrotable way
                dispatcher: "appStore"
            })

        end sub


        sub preRenderingFinished()
            m.proceedPageTransition()
            m.hideLoadingScreen()

            ' Pass the focus to framework's node (ONCE)
            m.parent.node.setFocus(true)

            ' Set the focus initially (ONCE)
            pageMenuWidget = m.getWidget("pageMenu")
            pageMenuWidget.plugins.focus.setFocus()

            ' Notify ready beacon (ONCE)
            m.node.signalBeacon("AppLaunchComplete")

        end sub

    end class

end namespace
