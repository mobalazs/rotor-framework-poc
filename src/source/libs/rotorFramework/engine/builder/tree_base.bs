namespace Rotor.ViewBuilder

    class TreeRoot

        node as object

        children = {}

        context = {}

        id = ""
        parentHID = ""
        HID = "0"
        vmHID = "0"
        isViewModel = true
        childrenHIDhash = {}

        sub render(payloads as dynamic, params = {} as object)
            for each payload in Rotor.Utils.ensureArray(payloads)
                if payload.DoesExist("id") = false and payload.DoesExist("HID") = false
                    payload.id = m.id
                    payload.HID = m.HID
                end if
            end for
            if Rotor.Utils.isValid(params.callback) then params.callbackScope = m
            globalScope = GetGlobalAA()
            globalScope.rotor_framework_helper.frameworkInstance.builder.render(payloads, params)
        end sub

        sub erase(payloads as dynamic)
            globalScope = GetGlobalAA()
            globalScope.rotor_framework_helper.frameworkInstance.builder.erase(payloads, m.parentHID)
        end sub

        sub destroy()
            m.node = invalid
        end sub

    end class

    class WidgetTree

        tree as object
        tree_HIDHash as object

        sub new()
            m.tree = new TreeRoot()
            m.tree_HIDHash = new Rotor.BaseStack()
        end sub

        sub init()
        end sub

        sub destroy()
            m.tree.destroy()
            m.tree_HIDHash.stack.Clear()
        end sub

        function add(config as object, ViewModelClass = invalid as ViewModel) as object

            if Rotor.Utils.isValid(ViewModelClass)
                widget = ViewModelClass().new() as ViewModel ' ViewModel extends Widget
            else
                widget = new Rotor.BaseWidget() as Rotor.BaseWidget ' Widget
            end if

            id = config.id

            ' Parse config properties
            widget.id = id
            widget.childrenHIDhash = {} ' preapare local HID cache
            widget.isRootChild = config.parentHID = "0" ' detect root
            widget.children = {} ' default

            ' Check if has parent widget
            if widget.isRootChild
                parent = m.tree
            else
                parent = m.get(config.parentHID)
            end if
            widget.parentHID = config.parentHID

            ' register as child by readable id
            parent.children[LCase(id)] = widget

            ' register as child by readable HID (Hierarchical Identifier)
            HID = m.generateHID(parent)
            parent.childrenHIDhash[HID] = true ' local cache for HID
            widget.HID = HID
            widget.parent = parent ' link parent widget

            if widget?.isViewModel = true
                widget.vmHID = widget.HID ' start new VM reference in hierarchy
            else
                widget.vmHID = parent.vmHID ' populate down the current VM reference in hierarchy
                VM = m.getByHID(parent.vmHID)
                widget.props = VM.props ' symlink :D to ancestor's viewModel's props (sharing props across descendant widgets)
                widget.context = VM.context ' symlink to ancestor ViewModel's context
            end if


            ' Buld the tree with the widget
            m.tree_HIDHash.set(HID, widget)

            return widget
        end function

        function generateHID(parent) as string
            tryCounter = 32
            newHID = ""
            ' Performance way
            while tryCounter > 0 and newHID = ""
                newHID = parent.HID + Rotor.Utils.getUUIDHex(3)
                if parent.childrenHIDhash.DoesExist(newHID) = true
                    newHID = ""
                end if
                tryCounter--
            end while
            ' Ok, then try another way (very rare scenario)
            if newHID = ""
                for decValue = 0 to 4095
                    hexValue = stri(decValue, 16)
                    newHID = parent.HID + hexValue
                    if parent.childrenHIDhash.DoesExist(newHID) = true
                        newHID = ""
                        exit for
                    end if
                end for
            end if
            return newHID
        end function

        function get(searchPattern as string, HID = "0" as string) as object
            untilFirstItem = true
            results = m.find(searchPattern, HID, untilFirstItem)
            if results = invalid
                return invalid
            else
                return results.shift()
            end if
        end function

        function hasByHID(HID as string) as boolean
            return m.tree_HIDHash.has(HID)
        end function

        function getByHID(HID as string) as object
            return HID = "0" ? m.tree : m.tree_HIDHash.get(HID)
        end function

        function getChildrenWidgets(searchPattern as string, HID = "0" as string) as object

            parentWidget = m.get(searchPattern, HID)
            if parentWidget = invalid then return invalid

            childrenWidgets = parentWidget.children.items()

            childrenWidgetsCount = childrenWidgets.Count()
            childrenNodes = parentWidget.node.getChildren(-1, 0)

            orderedWidgets = []
            for each node in childrenNodes
                isFound = false
                itemIndex = 0
                while isFound = false and itemIndex < childrenWidgetsCount
                    widget = childrenWidgets[itemIndex].value
                    if widget.node.isSameNode(node)
                        orderedWidgets.push(widget)
                        isFound = true
                    else
                        itemIndex++
                    end if
                end while
            end for

            return orderedWidgets
        end function

        sub remove (HID as string)
            widget = m.getByHID(HID)
            ' if widget = invalid then return

            ' remnove from parent
            parent = widget.parent
            parent.children.Delete(widget.id)

            parent.childrenHIDhash.Delete(widget.HID)

            m.tree_HIDHash.remove(HID)

            widget.dispatcherProvider = invalid
            widget.frameworkInstance = invalid

            widget.parent = invalid
            widget.context = invalid
            widget.props = invalid

            widget.node = invalid

            widget.Clear()

        end sub

        ' * Helpers

        function isBranchOfRemove(widget as object) as boolean
            if false = widget.DoesExist("markedToRemove") then return false
            if widget.isRootChild = true
                return true
            end if

            return widget.parent.DoesExist("markedToRemove") ? false : true
        end function

        function isBranchOfAppend(widget as object) as boolean
            if false = widget.DoesExist("markedToAppend") then return false
            if widget.isRootChild = true
                return true
            end if
            return widget.parent.DoesExist("markedToAppend") ? false : true
        end function

        function getTreeItem(HID)
            return HID = "" ? m.tree : m.getByHID(HID)
        end function

        function checkRegexIncluded(part as string) as object
            if Left(part, 6) = "regex:"
                return {
                    isRegex: true,
                    regex: CreateObject("roRegex", Right(part, Len(part) - 6), "i")
                }
            else
                return {
                    isRegex: false
                }
            end if
        end function

        sub setRootNode (node as object)
            m.tree.node = node
        end sub

        function getRootNode() as object
            return m.tree.node
        end function


        ' * search methods



        function find(searchPattern as string, HID = "0" as string, untilFirstItem = false as boolean) as object

            ' todo: However goals is to use find rarely, future improvement could be a well considered id-based cache.

            ' Check if search pattern is a HID
            if true = m.hasByHID(searchPattern)
                return [m.getByHID(searchPattern)]
            end if

            ' Check if searchpattern beginning with root operator
            beginningWith = Left(searchPattern, 2)
            if beginningWith = "./"
                searchPattern = Right(searchPattern, Len(searchPattern) - 2)
                ' In this case, drop reference HID and search from the root of full tree
                HID = "0"
            end if

            ' Normalize search patter: remove all slashes from the beginning of the search pattern
            searchPattern = /^\/*/.ReplaceAll(searchPattern, "")
            ' Normalize search patter: replace 2 or more slashes to 1
            searchPattern = /\/{2,}/.ReplaceAll(searchPattern, "/")
            ' Normalize search patter: replace 3 or more stars in a row to 2
            searchPattern = /\*{3,}/.ReplaceAll(searchPattern, "**")
            ' Normalize search patter: replace ending 2 stars to 1 star
            searchPattern = /\*\*$/.ReplaceAll(searchPattern, "*")
            ' Normalize search patter: replace multiple double-star paths to one. Example: **/**/**/ -> **/
            searchPattern = /(\*\*\/){2,}/.ReplaceAll(searchPattern, "**/")

            searchPattern = LCase(searchPattern)
            parts = /\//.Split(searchPattern)

            subTree = HID = "0" ? m.tree : m.getByHID(HID)
            ' Resolve ".." operators
            while parts[0] = ".." and subTree.HID <> "0"
                parts.shift()
                subTree = m.getByHID(subTree.parentHID)
            end while

            if parts[0] <> "**" then parts.unshift("**") ' this hide human mistakes

            results = []
            lastPart = parts[parts.Count() - 1]
            if subTree.HID <> "0" and subTree.id = lastPart then results.unshift(subTree)

            ' Start find
            m.recursion_find(results, parts, untilFirstItem, subTree.children)


            if results.Count() = 0 then return invalid

            return results
        end function

        ' This function is capable to find widgets in a tree structure based on glob pattern and regex
        function recursion_find(results as object, parts as object, untilFirstItem as boolean, children = {} as object, index = 0 as integer) as object

            part = parts[index]

            partsCount = parts.Count()
            isLastPart = partsCount - 1 = index
            nextPart = isLastPart ? "" : parts[index + 1]

            ' ? "/-----part: ";part
            if children.Count() > 0


                ' TODO: Future improvement: Write faster search recursion is possible
                ' if true = isLastPart
                '     if part = "*"
                '         results.append(children)
                '     end if
                ' else
                '     nextChildren = {}
                '     matchedParent = false
                '     if part = "**"
                '         if nextPart = "*"
                '             matchedParent = true
                '             nextChildren = children
                '         else if children.DoesExist(part)
                '             nextChildren = children[part].children
                '         end if
                '     else
                '         if part = "*"
                '             matchedParent = true
                '             nextChildren = widget.children
                '         else if children.DoesExist(part)
                '         end if
                '     end if


                for each id in children
                    widget = children[id]
                    ' ? id
                    if true = isLastPart
                        ' ? "isLastPart>  ";part;"  ";part = "*" or part = id
                        if part = "*" or part = id 'Lcase(id)
                            results.push(widget)
                            ' return with first hit
                            if untilFirstItem = true then return results
                        end if
                    else
                        nextChildren = {}
                        matchedParent = false
                        ' ? "part:";part;"  id:";id;"  nextPart:";nextPart
                        if part = "**"
                            if nextPart = "*" or nextPart = id ' Lcase(id)
                                matchedParent = true
                                nextChildren = children
                            else
                                nextChildren = widget.children
                            end if
                        else if part = "*" or part = id ' Lcase(id)
                            matchedParent = true
                            nextChildren = widget.children
                        end if
                        newIndex = matchedParent = true ? index + 1 : index
                        if nextChildren.Count() > 0 and newIndex < partsCount
                            m.recursion_find(results, parts, untilFirstItem, nextChildren, newIndex)
                        end if
                    end if
                end for
            end if
            return results
        end function

        function getSubtreeClone(searchPattern as string, keyPathList = [] as object, parentHID = "0" as string) as object
            subTree = m.get(searchPattern, parentHID)
            if subTree = invalid then return invalid

            ' keyPathList.push("id")
            keyPathList.push("HID")
            ' keyPathList.push("parentHID")

            subTreeClone = {}
            m.recursion_getSubtreeClone(subTree, subTreeClone, keyPathList)

            return subTreeClone
        end function

        ' Note that, there will be a type conversion: tree use AA for children but you will need Array for updates.
        sub recursion_getSubtreeClone(subTree as object, subTreeClone as object, keyPathList as object)
            ' Note that
            for each keyPath in keyPathList
                clonedValue = Rotor.Utils.getCloneByKeyPath(subTree, keyPath)
                if clonedValue <> invalid
                    Rotor.Utils.deepExtendAA(subTreeClone, clonedValue)
                end if
            end for
            if subTree.children <> invalid and subTree.children.Count() > 0
                subTreeClone.children = []
                childIndex = 0
                for each id in subTree.children
                    subTreeClone.children.push({ id: id })
                    m.recursion_getSubtreeClone(subTree.children[id], subTreeClone.children[childIndex], keyPathList)
                    childIndex++
                end for
            end if
        end sub



    end class

end namespace
